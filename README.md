Отчёт по Лабораторной работе №5 на тему «ФАЙЛЫ»

Цель работы
Освоить методы работы с бинарными и текстовыми файлами в C++, изучить особенности обработки различных типов данных в файлах, реализовать операции чтения, записи и обработки файловых данных.

Задание 1. Бинарные файлы с числовыми данными
Постановка задачи
Переписать в другой файл последовательного доступа те элементы, которые кратны k.

Алгоритм решения
Генерация исходного бинарного файла со случайными целыми числами
Открытие исходного файла для чтения в бинарном режиме
Открытие выходного файла для записи в бинарном режиме
Последовательное чтение чисел из исходного файла
Проверка каждого числа на кратность k
Запись подходящих чисел в выходной файл
Закрытие файлов

Структура кода
generateBinaryNumbers() - генерация случайных чисел в бинарный файл
copyMultiplesToFile() - копирование кратных чисел в другой файл
Использование std::ios::binary для бинарного режима
read()/write() с reinterpret_cast для работы с бинарными данными

Тесты для проверки

Тест 1:
Входные данные: k = 3, числа: 3, 7, 9, 12, 15
Ожидаемый результат: файл содержит 3, 9, 12, 15

Тест 2:
Входные данные: k = 5, числа: 2, 4, 6, 8, 10
Ожидаемый результат: файл содержит 10

Тест 3:
Входные данные: k = 7, числа: 14, 21, 28, 35
Ожидаемый результат: файл содержит 14, 21, 28, 35


Задание 2. Бинарные файлы с матрицами
Постановка задачи
Скопировать элементы заданного файла в квадратную матрицу размером n×n. Если элементов файла недостает, заполнить оставшиеся элементы матрицы нулями. Заменить все столбцы на столбец с минимальной суммой элементов.

Алгоритм решения
Генерация бинарного файла с n×n случайными числами
Чтение данных из файла в линейный массив размером n×n
Заполнение недостающих элементов нулями
Вычисление сумм элементов каждого столбца
Поиск столбца с минимальной суммой
Создание новой матрицы, где все столбцы заменены на найденный
Запись результата в выходной файл

Структура кода
generateMatrixFile() - генерация матрицы в файл
process MatrixFile() - обработка матрицы
Хранение матрицы в одномерном массиве для эффективности
Использование формулы row * n + col для доступа к элементам

Тесты для проверки

Тест 1 (n=3):
Исходная матрица:    Минимальный столбец:  Новые столбцы:
[1 2 3]              [1]                   [1 1 1]
[4 5 6]    →         [4]          →        [4 4 4]
[7 8 9]              [7]                   [7 7 7]

Тест 2 (недостаток данных):
Файл содержит: 1, 2, 3, 4
n=3 → матрица: [1 2 3]
               [4 0 0]
               [0 0 0]


Задание 3. Бинарные файлы со структурами
Постановка задачи
Файл содержит сведения об игрушках: название игрушки, ее стоимость в рублях и возрастные границы. Определить стоимость самого дорогого конструктора.

Алгоритм решения
Определение структуры Toy с полями:
name[50] - название игрушки
price - стоимость
minAge, maxAge - возрастные границы
Генерация файла со случайными игрушками
Последовательное чтение структур из файла
Поиск подстроки "Конструктор" в названии
Сравнение цен для нахождения максимальной
Вывод результата

Структура кода
Структура Toy с фиксированным размером
generateToysFile() - генерация данных
findMostExpensiveConstructor() - поиск максимальной цены
Использование strncpy() для безопасного копирования строк

Тесты для проверки

Тест 1:
Игрушки: "Конструктор Lego" - 3000 руб.
         "Мяч" - 500 руб.
         "Конструктор металлический" - 4500 руб.
Результат: 4500 руб.

Тест 2:
Игрушки: "Кукла" - 1500 руб.
         "Машинка" - 2000 руб.
Результат: 0 (конструкторов нет)


Задание 4. Текстовые файлы (одно число в строке)
Постановка задачи
Найти сумму тех элементов файла, которые равны своему индексу (индексацию элементов файла начинать с нуля).

Алгоритм решения
Генерация текстового файла с одним числом в каждой строке
Последовательное чтение чисел из файла
Подсчет индекса текущего элемента
Сравнение значения элемента с его индексом
Добавление к сумме при совпадении
Возврат общей суммы

Структура кода
generateTextNumbers1() - генерация чисел по одному в строке
sumElementsEqualToIndex() - вычисление суммы
Использование while (file >> num) для чтения чисел

Тесты для проверки

Тест 1:
Файл:    Индексы:    Совпадения:
0        0           +0 = 0
5        1           -
2        2           +2 = 2
3        3           +3 = 5
Результат: 5

Тест 2:
Файл: 1, 1, 2, 3, 5
Результат: 6 (1+2+3)


Задание 5. Текстовые файлы (несколько чисел в строке)
Постановка задачи
Вычислить произведение элементов, которые кратны заданному числу k.

Алгоритм решения
Генерация текстового файла с несколькими числами в каждой строке
Чтение всех чисел из файла (оператор >> игнорирует разделители)
Проверка каждого числа на кратность k
Умножение подходящих чисел
Возврат произведения (0 если нет кратных чисел)

Структура кода
generateTextNumbers2() - генерация с заданным количеством чисел в строке
multiplyMultiples() - вычисление произведения
Использование long long для предотвращения переполнения

Тесты для проверки

Тест 1 (k=3):
Файл: 3 6 9 2 12
Произведение: 3×6×9×12 = 1944

Тест 2 (k=5):
Файл: 2 4 6 8
Произведение: 0 (нет кратных)

Тест 3 (k=1):
Файл: любая последовательность
Произведение: произведение всех чисел

Задание 6. Текстовые файлы с фильтрацией
Постановка задачи
Переписать в другой файл строки, в которых нет русских букв.

Алгоритм решения
Генерация текстового файла со смешанными строками
Определение функции проверки наличия русских букв
Последовательное чтение строк из файла
Проверка каждой строки на отсутствие русских букв
Запись подходящих строк в выходной файл

Структура кода
generateTextFile() - генерация текста
isRussianChar() - проверка символа
hasRussianLetters() - проверка строки
copyLinesWithoutRussian() - фильтрация строк
Использование std::getline() для чтения целых строк

Тесты для проверки

Тест 1:
Исходный файл:
"Hello world"
"Привет мир"
"Test line"
"Строка с русскими"

Результирующий файл:
"Hello world"
"Test line"

Выводы
Бинарные файлы эффективнее для хранения числовых данных и структур, так как сохраняют точное представление данных без преобразований.
Текстовые файлы более удобны для человеческого чтения и отладки, но требуют преобразования типов данных при чтении/записи.
Структуры в бинарных файлах требуют фиксированного размера полей, особенно для строковых данных, что необходимо учитывать при проектировании.
Обработка матриц из файлов требует тщательной проверки количества доступных данных и обработки случаев нехватки информации.
Операции фильтрации с текстовыми данными демонстрируют важность корректной обработки кодировок и строковых операций.
Статические методы класса обеспечивают удобную организацию кода для утилитных операций, соответствующих парадигме "все в одном классе".
Разделение на заголовочные и исходные файлы (Stanford Code Style) улучшает читаемость, поддерживаемость и позволяет раздельной компиляции.
Обработка ошибок при работе с файлами (проверка открытия, чтения, записи) является критически важной для создания надежных программ.

Работа продемонстрировала практические навыки работы с файловой системой в C++, понимание различий между бинарными и текстовыми файлами, а также умение организовывать код в соответствии с профессиональными стандартами.
